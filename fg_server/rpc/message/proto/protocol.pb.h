// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/protocol.proto

#ifndef PROTOBUF_proto_2fprotocol_2eproto__INCLUDED
#define PROTOBUF_proto_2fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/proto.pb.h"
// @@protoc_insertion_point(includes)

namespace TankProtocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fprotocol_2eproto();
void protobuf_AssignDesc_proto_2fprotocol_2eproto();
void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

class cEnter;
class cTankNode;
class sEnter;
class sAddTank;
class cGetTankList;
class sGetTankList;
class cAttack;
class sAttack;
class cUpdateTankPos;
class cAddBuff;
class sAddBuff;
class sAddBuffToBattleField;
class sCleanBuff;
class cGetBuffList;
class sGetBuffList;
class cCannonNode;
class cGetCannonList;
class sGetCannonList;
class sUpdateCannonAttack;
class cDeath;
class sDeath;
class cReborn;
class sReborn;
class sLogout;

// ===================================================================

class cEnter : public ::google::protobuf::Message {
 public:
  cEnter();
  virtual ~cEnter();

  cEnter(const cEnter& from);

  inline cEnter& operator=(const cEnter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cEnter& default_instance();

  void Swap(cEnter* other);

  // implements Message ----------------------------------------------

  cEnter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cEnter& from);
  void MergeFrom(const cEnter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TankProtocol.cEnter)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static cEnter* default_instance_;
};
// -------------------------------------------------------------------

class cTankNode : public ::google::protobuf::Message {
 public:
  cTankNode();
  virtual ~cTankNode();

  cTankNode(const cTankNode& from);

  inline cTankNode& operator=(const cTankNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cTankNode& default_instance();

  void Swap(cTankNode* other);

  // implements Message ----------------------------------------------

  cTankNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cTankNode& from);
  void MergeFrom(const cTankNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required .cVector3 position1 = 2;
  inline bool has_position1() const;
  inline void clear_position1();
  static const int kPosition1FieldNumber = 2;
  inline const ::cVector3& position1() const;
  inline ::cVector3* mutable_position1();
  inline ::cVector3* release_position1();
  inline void set_allocated_position1(::cVector3* position1);

  // required .cVector3 position2 = 3;
  inline bool has_position2() const;
  inline void clear_position2();
  static const int kPosition2FieldNumber = 3;
  inline const ::cVector3& position2() const;
  inline ::cVector3* mutable_position2();
  inline ::cVector3* release_position2();
  inline void set_allocated_position2(::cVector3* position2);

  // required .cVector3 position3 = 4;
  inline bool has_position3() const;
  inline void clear_position3();
  static const int kPosition3FieldNumber = 4;
  inline const ::cVector3& position3() const;
  inline ::cVector3* mutable_position3();
  inline ::cVector3* release_position3();
  inline void set_allocated_position3(::cVector3* position3);

  // required .cVector3 direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline const ::cVector3& direction() const;
  inline ::cVector3* mutable_direction();
  inline ::cVector3* release_direction();
  inline void set_allocated_direction(::cVector3* direction);

  // optional int32 hp = 6;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 6;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // required int32 damage = 7;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 7;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // repeated .cBufferNode list = 8;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 8;
  inline const ::cBufferNode& list(int index) const;
  inline ::cBufferNode* mutable_list(int index);
  inline ::cBufferNode* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::cBufferNode >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::cBufferNode >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:TankProtocol.cTankNode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_position1();
  inline void clear_has_position1();
  inline void set_has_position2();
  inline void clear_has_position2();
  inline void set_has_position3();
  inline void clear_has_position3();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::cVector3* position1_;
  ::cVector3* position2_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 hp_;
  ::cVector3* position3_;
  ::cVector3* direction_;
  ::google::protobuf::RepeatedPtrField< ::cBufferNode > list_;
  ::google::protobuf::int32 damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static cTankNode* default_instance_;
};
// -------------------------------------------------------------------

class sEnter : public ::google::protobuf::Message {
 public:
  sEnter();
  virtual ~sEnter();

  sEnter(const sEnter& from);

  inline sEnter& operator=(const sEnter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sEnter& default_instance();

  void Swap(sEnter* other);

  // implements Message ----------------------------------------------

  sEnter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sEnter& from);
  void MergeFrom(const sEnter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:TankProtocol.sEnter)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sEnter* default_instance_;
};
// -------------------------------------------------------------------

class sAddTank : public ::google::protobuf::Message {
 public:
  sAddTank();
  virtual ~sAddTank();

  sAddTank(const sAddTank& from);

  inline sAddTank& operator=(const sAddTank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sAddTank& default_instance();

  void Swap(sAddTank* other);

  // implements Message ----------------------------------------------

  sAddTank* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sAddTank& from);
  void MergeFrom(const sAddTank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TankProtocol.cTankNode node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::TankProtocol::cTankNode& node() const;
  inline ::TankProtocol::cTankNode* mutable_node();
  inline ::TankProtocol::cTankNode* release_node();
  inline void set_allocated_node(::TankProtocol::cTankNode* node);

  // @@protoc_insertion_point(class_scope:TankProtocol.sAddTank)
 private:
  inline void set_has_node();
  inline void clear_has_node();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TankProtocol::cTankNode* node_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sAddTank* default_instance_;
};
// -------------------------------------------------------------------

class cGetTankList : public ::google::protobuf::Message {
 public:
  cGetTankList();
  virtual ~cGetTankList();

  cGetTankList(const cGetTankList& from);

  inline cGetTankList& operator=(const cGetTankList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cGetTankList& default_instance();

  void Swap(cGetTankList* other);

  // implements Message ----------------------------------------------

  cGetTankList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cGetTankList& from);
  void MergeFrom(const cGetTankList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TankProtocol.cGetTankList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static cGetTankList* default_instance_;
};
// -------------------------------------------------------------------

class sGetTankList : public ::google::protobuf::Message {
 public:
  sGetTankList();
  virtual ~sGetTankList();

  sGetTankList(const sGetTankList& from);

  inline sGetTankList& operator=(const sGetTankList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sGetTankList& default_instance();

  void Swap(sGetTankList* other);

  // implements Message ----------------------------------------------

  sGetTankList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sGetTankList& from);
  void MergeFrom(const sGetTankList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TankProtocol.cTankNode list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::TankProtocol::cTankNode& list(int index) const;
  inline ::TankProtocol::cTankNode* mutable_list(int index);
  inline ::TankProtocol::cTankNode* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::TankProtocol::cTankNode >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::TankProtocol::cTankNode >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:TankProtocol.sGetTankList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TankProtocol::cTankNode > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sGetTankList* default_instance_;
};
// -------------------------------------------------------------------

class cAttack : public ::google::protobuf::Message {
 public:
  cAttack();
  virtual ~cAttack();

  cAttack(const cAttack& from);

  inline cAttack& operator=(const cAttack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cAttack& default_instance();

  void Swap(cAttack* other);

  // implements Message ----------------------------------------------

  cAttack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cAttack& from);
  void MergeFrom(const cAttack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 AttackTankId = 1;
  inline bool has_attacktankid() const;
  inline void clear_attacktankid();
  static const int kAttackTankIdFieldNumber = 1;
  inline ::google::protobuf::int32 attacktankid() const;
  inline void set_attacktankid(::google::protobuf::int32 value);

  // required int32 beAttackedTankId = 2;
  inline bool has_beattackedtankid() const;
  inline void clear_beattackedtankid();
  static const int kBeAttackedTankIdFieldNumber = 2;
  inline ::google::protobuf::int32 beattackedtankid() const;
  inline void set_beattackedtankid(::google::protobuf::int32 value);

  // required int32 damage = 3;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 3;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.cAttack)
 private:
  inline void set_has_attacktankid();
  inline void clear_has_attacktankid();
  inline void set_has_beattackedtankid();
  inline void clear_has_beattackedtankid();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 attacktankid_;
  ::google::protobuf::int32 beattackedtankid_;
  ::google::protobuf::int32 damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static cAttack* default_instance_;
};
// -------------------------------------------------------------------

class sAttack : public ::google::protobuf::Message {
 public:
  sAttack();
  virtual ~sAttack();

  sAttack(const sAttack& from);

  inline sAttack& operator=(const sAttack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sAttack& default_instance();

  void Swap(sAttack* other);

  // implements Message ----------------------------------------------

  sAttack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sAttack& from);
  void MergeFrom(const sAttack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 AttackTankId = 1;
  inline bool has_attacktankid() const;
  inline void clear_attacktankid();
  static const int kAttackTankIdFieldNumber = 1;
  inline ::google::protobuf::int32 attacktankid() const;
  inline void set_attacktankid(::google::protobuf::int32 value);

  // required int32 beAttackedTankId = 2;
  inline bool has_beattackedtankid() const;
  inline void clear_beattackedtankid();
  static const int kBeAttackedTankIdFieldNumber = 2;
  inline ::google::protobuf::int32 beattackedtankid() const;
  inline void set_beattackedtankid(::google::protobuf::int32 value);

  // required int32 damage = 3;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 3;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.sAttack)
 private:
  inline void set_has_attacktankid();
  inline void clear_has_attacktankid();
  inline void set_has_beattackedtankid();
  inline void clear_has_beattackedtankid();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 attacktankid_;
  ::google::protobuf::int32 beattackedtankid_;
  ::google::protobuf::int32 damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sAttack* default_instance_;
};
// -------------------------------------------------------------------

class cUpdateTankPos : public ::google::protobuf::Message {
 public:
  cUpdateTankPos();
  virtual ~cUpdateTankPos();

  cUpdateTankPos(const cUpdateTankPos& from);

  inline cUpdateTankPos& operator=(const cUpdateTankPos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cUpdateTankPos& default_instance();

  void Swap(cUpdateTankPos* other);

  // implements Message ----------------------------------------------

  cUpdateTankPos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cUpdateTankPos& from);
  void MergeFrom(const cUpdateTankPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tankId = 1;
  inline bool has_tankid() const;
  inline void clear_tankid();
  static const int kTankIdFieldNumber = 1;
  inline ::google::protobuf::int32 tankid() const;
  inline void set_tankid(::google::protobuf::int32 value);

  // required .cVector3 position1 = 2;
  inline bool has_position1() const;
  inline void clear_position1();
  static const int kPosition1FieldNumber = 2;
  inline const ::cVector3& position1() const;
  inline ::cVector3* mutable_position1();
  inline ::cVector3* release_position1();
  inline void set_allocated_position1(::cVector3* position1);

  // required .cVector3 position2 = 3;
  inline bool has_position2() const;
  inline void clear_position2();
  static const int kPosition2FieldNumber = 3;
  inline const ::cVector3& position2() const;
  inline ::cVector3* mutable_position2();
  inline ::cVector3* release_position2();
  inline void set_allocated_position2(::cVector3* position2);

  // required .cVector3 position3 = 4;
  inline bool has_position3() const;
  inline void clear_position3();
  static const int kPosition3FieldNumber = 4;
  inline const ::cVector3& position3() const;
  inline ::cVector3* mutable_position3();
  inline ::cVector3* release_position3();
  inline void set_allocated_position3(::cVector3* position3);

  // required .cVector3 direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline const ::cVector3& direction() const;
  inline ::cVector3* mutable_direction();
  inline ::cVector3* release_direction();
  inline void set_allocated_direction(::cVector3* direction);

  // optional int32 hp = 6;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 6;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // required int32 damage = 7;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 7;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // repeated .cBufferNode list = 8;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 8;
  inline const ::cBufferNode& list(int index) const;
  inline ::cBufferNode* mutable_list(int index);
  inline ::cBufferNode* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::cBufferNode >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::cBufferNode >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:TankProtocol.cUpdateTankPos)
 private:
  inline void set_has_tankid();
  inline void clear_has_tankid();
  inline void set_has_position1();
  inline void clear_has_position1();
  inline void set_has_position2();
  inline void clear_has_position2();
  inline void set_has_position3();
  inline void clear_has_position3();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::cVector3* position1_;
  ::cVector3* position2_;
  ::google::protobuf::int32 tankid_;
  ::google::protobuf::int32 hp_;
  ::cVector3* position3_;
  ::cVector3* direction_;
  ::google::protobuf::RepeatedPtrField< ::cBufferNode > list_;
  ::google::protobuf::int32 damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static cUpdateTankPos* default_instance_;
};
// -------------------------------------------------------------------

class cAddBuff : public ::google::protobuf::Message {
 public:
  cAddBuff();
  virtual ~cAddBuff();

  cAddBuff(const cAddBuff& from);

  inline cAddBuff& operator=(const cAddBuff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cAddBuff& default_instance();

  void Swap(cAddBuff* other);

  // implements Message ----------------------------------------------

  cAddBuff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cAddBuff& from);
  void MergeFrom(const cAddBuff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tankId = 1;
  inline bool has_tankid() const;
  inline void clear_tankid();
  static const int kTankIdFieldNumber = 1;
  inline ::google::protobuf::int32 tankid() const;
  inline void set_tankid(::google::protobuf::int32 value);

  // required int32 bufferId = 2;
  inline bool has_bufferid() const;
  inline void clear_bufferid();
  static const int kBufferIdFieldNumber = 2;
  inline ::google::protobuf::int32 bufferid() const;
  inline void set_bufferid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.cAddBuff)
 private:
  inline void set_has_tankid();
  inline void clear_has_tankid();
  inline void set_has_bufferid();
  inline void clear_has_bufferid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tankid_;
  ::google::protobuf::int32 bufferid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static cAddBuff* default_instance_;
};
// -------------------------------------------------------------------

class sAddBuff : public ::google::protobuf::Message {
 public:
  sAddBuff();
  virtual ~sAddBuff();

  sAddBuff(const sAddBuff& from);

  inline sAddBuff& operator=(const sAddBuff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sAddBuff& default_instance();

  void Swap(sAddBuff* other);

  // implements Message ----------------------------------------------

  sAddBuff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sAddBuff& from);
  void MergeFrom(const sAddBuff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tankId = 1;
  inline bool has_tankid() const;
  inline void clear_tankid();
  static const int kTankIdFieldNumber = 1;
  inline ::google::protobuf::int32 tankid() const;
  inline void set_tankid(::google::protobuf::int32 value);

  // required int32 bufferId = 2;
  inline bool has_bufferid() const;
  inline void clear_bufferid();
  static const int kBufferIdFieldNumber = 2;
  inline ::google::protobuf::int32 bufferid() const;
  inline void set_bufferid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.sAddBuff)
 private:
  inline void set_has_tankid();
  inline void clear_has_tankid();
  inline void set_has_bufferid();
  inline void clear_has_bufferid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tankid_;
  ::google::protobuf::int32 bufferid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sAddBuff* default_instance_;
};
// -------------------------------------------------------------------

class sAddBuffToBattleField : public ::google::protobuf::Message {
 public:
  sAddBuffToBattleField();
  virtual ~sAddBuffToBattleField();

  sAddBuffToBattleField(const sAddBuffToBattleField& from);

  inline sAddBuffToBattleField& operator=(const sAddBuffToBattleField& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sAddBuffToBattleField& default_instance();

  void Swap(sAddBuffToBattleField* other);

  // implements Message ----------------------------------------------

  sAddBuffToBattleField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sAddBuffToBattleField& from);
  void MergeFrom(const sAddBuffToBattleField& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .cBufferNode buffer = 1;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 1;
  inline const ::cBufferNode& buffer() const;
  inline ::cBufferNode* mutable_buffer();
  inline ::cBufferNode* release_buffer();
  inline void set_allocated_buffer(::cBufferNode* buffer);

  // @@protoc_insertion_point(class_scope:TankProtocol.sAddBuffToBattleField)
 private:
  inline void set_has_buffer();
  inline void clear_has_buffer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::cBufferNode* buffer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sAddBuffToBattleField* default_instance_;
};
// -------------------------------------------------------------------

class sCleanBuff : public ::google::protobuf::Message {
 public:
  sCleanBuff();
  virtual ~sCleanBuff();

  sCleanBuff(const sCleanBuff& from);

  inline sCleanBuff& operator=(const sCleanBuff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sCleanBuff& default_instance();

  void Swap(sCleanBuff* other);

  // implements Message ----------------------------------------------

  sCleanBuff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sCleanBuff& from);
  void MergeFrom(const sCleanBuff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.sCleanBuff)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sCleanBuff* default_instance_;
};
// -------------------------------------------------------------------

class cGetBuffList : public ::google::protobuf::Message {
 public:
  cGetBuffList();
  virtual ~cGetBuffList();

  cGetBuffList(const cGetBuffList& from);

  inline cGetBuffList& operator=(const cGetBuffList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cGetBuffList& default_instance();

  void Swap(cGetBuffList* other);

  // implements Message ----------------------------------------------

  cGetBuffList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cGetBuffList& from);
  void MergeFrom(const cGetBuffList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TankProtocol.cGetBuffList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static cGetBuffList* default_instance_;
};
// -------------------------------------------------------------------

class sGetBuffList : public ::google::protobuf::Message {
 public:
  sGetBuffList();
  virtual ~sGetBuffList();

  sGetBuffList(const sGetBuffList& from);

  inline sGetBuffList& operator=(const sGetBuffList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sGetBuffList& default_instance();

  void Swap(sGetBuffList* other);

  // implements Message ----------------------------------------------

  sGetBuffList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sGetBuffList& from);
  void MergeFrom(const sGetBuffList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cBufferNode list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::cBufferNode& list(int index) const;
  inline ::cBufferNode* mutable_list(int index);
  inline ::cBufferNode* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::cBufferNode >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::cBufferNode >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:TankProtocol.sGetBuffList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::cBufferNode > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sGetBuffList* default_instance_;
};
// -------------------------------------------------------------------

class cCannonNode : public ::google::protobuf::Message {
 public:
  cCannonNode();
  virtual ~cCannonNode();

  cCannonNode(const cCannonNode& from);

  inline cCannonNode& operator=(const cCannonNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cCannonNode& default_instance();

  void Swap(cCannonNode* other);

  // implements Message ----------------------------------------------

  cCannonNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cCannonNode& from);
  void MergeFrom(const cCannonNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 cannonId = 1;
  inline bool has_cannonid() const;
  inline void clear_cannonid();
  static const int kCannonIdFieldNumber = 1;
  inline ::google::protobuf::int32 cannonid() const;
  inline void set_cannonid(::google::protobuf::int32 value);

  // required .cVector3 position1 = 2;
  inline bool has_position1() const;
  inline void clear_position1();
  static const int kPosition1FieldNumber = 2;
  inline const ::cVector3& position1() const;
  inline ::cVector3* mutable_position1();
  inline ::cVector3* release_position1();
  inline void set_allocated_position1(::cVector3* position1);

  // required .cVector3 position2 = 3;
  inline bool has_position2() const;
  inline void clear_position2();
  static const int kPosition2FieldNumber = 3;
  inline const ::cVector3& position2() const;
  inline ::cVector3* mutable_position2();
  inline ::cVector3* release_position2();
  inline void set_allocated_position2(::cVector3* position2);

  // required .cVector3 position3 = 4;
  inline bool has_position3() const;
  inline void clear_position3();
  static const int kPosition3FieldNumber = 4;
  inline const ::cVector3& position3() const;
  inline ::cVector3* mutable_position3();
  inline ::cVector3* release_position3();
  inline void set_allocated_position3(::cVector3* position3);

  // required .cVector3 direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline const ::cVector3& direction() const;
  inline ::cVector3* mutable_direction();
  inline ::cVector3* release_direction();
  inline void set_allocated_direction(::cVector3* direction);

  // required int32 damage = 6;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 6;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // required int32 area = 7;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 7;
  inline ::google::protobuf::int32 area() const;
  inline void set_area(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.cCannonNode)
 private:
  inline void set_has_cannonid();
  inline void clear_has_cannonid();
  inline void set_has_position1();
  inline void clear_has_position1();
  inline void set_has_position2();
  inline void clear_has_position2();
  inline void set_has_position3();
  inline void clear_has_position3();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_area();
  inline void clear_has_area();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::cVector3* position1_;
  ::cVector3* position2_;
  ::google::protobuf::int32 cannonid_;
  ::google::protobuf::int32 damage_;
  ::cVector3* position3_;
  ::cVector3* direction_;
  ::google::protobuf::int32 area_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static cCannonNode* default_instance_;
};
// -------------------------------------------------------------------

class cGetCannonList : public ::google::protobuf::Message {
 public:
  cGetCannonList();
  virtual ~cGetCannonList();

  cGetCannonList(const cGetCannonList& from);

  inline cGetCannonList& operator=(const cGetCannonList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cGetCannonList& default_instance();

  void Swap(cGetCannonList* other);

  // implements Message ----------------------------------------------

  cGetCannonList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cGetCannonList& from);
  void MergeFrom(const cGetCannonList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TankProtocol.cGetCannonList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static cGetCannonList* default_instance_;
};
// -------------------------------------------------------------------

class sGetCannonList : public ::google::protobuf::Message {
 public:
  sGetCannonList();
  virtual ~sGetCannonList();

  sGetCannonList(const sGetCannonList& from);

  inline sGetCannonList& operator=(const sGetCannonList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sGetCannonList& default_instance();

  void Swap(sGetCannonList* other);

  // implements Message ----------------------------------------------

  sGetCannonList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sGetCannonList& from);
  void MergeFrom(const sGetCannonList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TankProtocol.cCannonNode list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::TankProtocol::cCannonNode& list(int index) const;
  inline ::TankProtocol::cCannonNode* mutable_list(int index);
  inline ::TankProtocol::cCannonNode* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::TankProtocol::cCannonNode >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::TankProtocol::cCannonNode >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:TankProtocol.sGetCannonList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TankProtocol::cCannonNode > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sGetCannonList* default_instance_;
};
// -------------------------------------------------------------------

class sUpdateCannonAttack : public ::google::protobuf::Message {
 public:
  sUpdateCannonAttack();
  virtual ~sUpdateCannonAttack();

  sUpdateCannonAttack(const sUpdateCannonAttack& from);

  inline sUpdateCannonAttack& operator=(const sUpdateCannonAttack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sUpdateCannonAttack& default_instance();

  void Swap(sUpdateCannonAttack* other);

  // implements Message ----------------------------------------------

  sUpdateCannonAttack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sUpdateCannonAttack& from);
  void MergeFrom(const sUpdateCannonAttack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 cannonId = 1;
  inline bool has_cannonid() const;
  inline void clear_cannonid();
  static const int kCannonIdFieldNumber = 1;
  inline ::google::protobuf::int32 cannonid() const;
  inline void set_cannonid(::google::protobuf::int32 value);

  // required int32 tankId = 2;
  inline bool has_tankid() const;
  inline void clear_tankid();
  static const int kTankIdFieldNumber = 2;
  inline ::google::protobuf::int32 tankid() const;
  inline void set_tankid(::google::protobuf::int32 value);

  // required int32 damage = 3;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 3;
  inline ::google::protobuf::int32 damage() const;
  inline void set_damage(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.sUpdateCannonAttack)
 private:
  inline void set_has_cannonid();
  inline void clear_has_cannonid();
  inline void set_has_tankid();
  inline void clear_has_tankid();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 cannonid_;
  ::google::protobuf::int32 tankid_;
  ::google::protobuf::int32 damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sUpdateCannonAttack* default_instance_;
};
// -------------------------------------------------------------------

class cDeath : public ::google::protobuf::Message {
 public:
  cDeath();
  virtual ~cDeath();

  cDeath(const cDeath& from);

  inline cDeath& operator=(const cDeath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cDeath& default_instance();

  void Swap(cDeath* other);

  // implements Message ----------------------------------------------

  cDeath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cDeath& from);
  void MergeFrom(const cDeath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tankId = 1;
  inline bool has_tankid() const;
  inline void clear_tankid();
  static const int kTankIdFieldNumber = 1;
  inline ::google::protobuf::int32 tankid() const;
  inline void set_tankid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.cDeath)
 private:
  inline void set_has_tankid();
  inline void clear_has_tankid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tankid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static cDeath* default_instance_;
};
// -------------------------------------------------------------------

class sDeath : public ::google::protobuf::Message {
 public:
  sDeath();
  virtual ~sDeath();

  sDeath(const sDeath& from);

  inline sDeath& operator=(const sDeath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sDeath& default_instance();

  void Swap(sDeath* other);

  // implements Message ----------------------------------------------

  sDeath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sDeath& from);
  void MergeFrom(const sDeath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tankId = 1;
  inline bool has_tankid() const;
  inline void clear_tankid();
  static const int kTankIdFieldNumber = 1;
  inline ::google::protobuf::int32 tankid() const;
  inline void set_tankid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.sDeath)
 private:
  inline void set_has_tankid();
  inline void clear_has_tankid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tankid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sDeath* default_instance_;
};
// -------------------------------------------------------------------

class cReborn : public ::google::protobuf::Message {
 public:
  cReborn();
  virtual ~cReborn();

  cReborn(const cReborn& from);

  inline cReborn& operator=(const cReborn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cReborn& default_instance();

  void Swap(cReborn* other);

  // implements Message ----------------------------------------------

  cReborn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cReborn& from);
  void MergeFrom(const cReborn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tankId = 1;
  inline bool has_tankid() const;
  inline void clear_tankid();
  static const int kTankIdFieldNumber = 1;
  inline ::google::protobuf::int32 tankid() const;
  inline void set_tankid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.cReborn)
 private:
  inline void set_has_tankid();
  inline void clear_has_tankid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tankid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static cReborn* default_instance_;
};
// -------------------------------------------------------------------

class sReborn : public ::google::protobuf::Message {
 public:
  sReborn();
  virtual ~sReborn();

  sReborn(const sReborn& from);

  inline sReborn& operator=(const sReborn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sReborn& default_instance();

  void Swap(sReborn* other);

  // implements Message ----------------------------------------------

  sReborn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sReborn& from);
  void MergeFrom(const sReborn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tankId = 1;
  inline bool has_tankid() const;
  inline void clear_tankid();
  static const int kTankIdFieldNumber = 1;
  inline ::google::protobuf::int32 tankid() const;
  inline void set_tankid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.sReborn)
 private:
  inline void set_has_tankid();
  inline void clear_has_tankid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tankid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sReborn* default_instance_;
};
// -------------------------------------------------------------------

class sLogout : public ::google::protobuf::Message {
 public:
  sLogout();
  virtual ~sLogout();

  sLogout(const sLogout& from);

  inline sLogout& operator=(const sLogout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sLogout& default_instance();

  void Swap(sLogout* other);

  // implements Message ----------------------------------------------

  sLogout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sLogout& from);
  void MergeFrom(const sLogout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tankId = 1;
  inline bool has_tankid() const;
  inline void clear_tankid();
  static const int kTankIdFieldNumber = 1;
  inline ::google::protobuf::int32 tankid() const;
  inline void set_tankid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TankProtocol.sLogout)
 private:
  inline void set_has_tankid();
  inline void clear_has_tankid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tankid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol_2eproto();

  void InitAsDefaultInstance();
  static sLogout* default_instance_;
};
// ===================================================================


// ===================================================================

// cEnter

// -------------------------------------------------------------------

// cTankNode

// required int32 id = 1;
inline bool cTankNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cTankNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cTankNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cTankNode::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 cTankNode::id() const {
  return id_;
}
inline void cTankNode::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required .cVector3 position1 = 2;
inline bool cTankNode::has_position1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cTankNode::set_has_position1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cTankNode::clear_has_position1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cTankNode::clear_position1() {
  if (position1_ != NULL) position1_->::cVector3::Clear();
  clear_has_position1();
}
inline const ::cVector3& cTankNode::position1() const {
  return position1_ != NULL ? *position1_ : *default_instance_->position1_;
}
inline ::cVector3* cTankNode::mutable_position1() {
  set_has_position1();
  if (position1_ == NULL) position1_ = new ::cVector3;
  return position1_;
}
inline ::cVector3* cTankNode::release_position1() {
  clear_has_position1();
  ::cVector3* temp = position1_;
  position1_ = NULL;
  return temp;
}
inline void cTankNode::set_allocated_position1(::cVector3* position1) {
  delete position1_;
  position1_ = position1;
  if (position1) {
    set_has_position1();
  } else {
    clear_has_position1();
  }
}

// required .cVector3 position2 = 3;
inline bool cTankNode::has_position2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cTankNode::set_has_position2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cTankNode::clear_has_position2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cTankNode::clear_position2() {
  if (position2_ != NULL) position2_->::cVector3::Clear();
  clear_has_position2();
}
inline const ::cVector3& cTankNode::position2() const {
  return position2_ != NULL ? *position2_ : *default_instance_->position2_;
}
inline ::cVector3* cTankNode::mutable_position2() {
  set_has_position2();
  if (position2_ == NULL) position2_ = new ::cVector3;
  return position2_;
}
inline ::cVector3* cTankNode::release_position2() {
  clear_has_position2();
  ::cVector3* temp = position2_;
  position2_ = NULL;
  return temp;
}
inline void cTankNode::set_allocated_position2(::cVector3* position2) {
  delete position2_;
  position2_ = position2;
  if (position2) {
    set_has_position2();
  } else {
    clear_has_position2();
  }
}

// required .cVector3 position3 = 4;
inline bool cTankNode::has_position3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cTankNode::set_has_position3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cTankNode::clear_has_position3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cTankNode::clear_position3() {
  if (position3_ != NULL) position3_->::cVector3::Clear();
  clear_has_position3();
}
inline const ::cVector3& cTankNode::position3() const {
  return position3_ != NULL ? *position3_ : *default_instance_->position3_;
}
inline ::cVector3* cTankNode::mutable_position3() {
  set_has_position3();
  if (position3_ == NULL) position3_ = new ::cVector3;
  return position3_;
}
inline ::cVector3* cTankNode::release_position3() {
  clear_has_position3();
  ::cVector3* temp = position3_;
  position3_ = NULL;
  return temp;
}
inline void cTankNode::set_allocated_position3(::cVector3* position3) {
  delete position3_;
  position3_ = position3;
  if (position3) {
    set_has_position3();
  } else {
    clear_has_position3();
  }
}

// required .cVector3 direction = 5;
inline bool cTankNode::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cTankNode::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cTankNode::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cTankNode::clear_direction() {
  if (direction_ != NULL) direction_->::cVector3::Clear();
  clear_has_direction();
}
inline const ::cVector3& cTankNode::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::cVector3* cTankNode::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::cVector3;
  return direction_;
}
inline ::cVector3* cTankNode::release_direction() {
  clear_has_direction();
  ::cVector3* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void cTankNode::set_allocated_direction(::cVector3* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
}

// optional int32 hp = 6;
inline bool cTankNode::has_hp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cTankNode::set_has_hp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cTankNode::clear_has_hp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cTankNode::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 cTankNode::hp() const {
  return hp_;
}
inline void cTankNode::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// required int32 damage = 7;
inline bool cTankNode::has_damage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cTankNode::set_has_damage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cTankNode::clear_has_damage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cTankNode::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 cTankNode::damage() const {
  return damage_;
}
inline void cTankNode::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
}

// repeated .cBufferNode list = 8;
inline int cTankNode::list_size() const {
  return list_.size();
}
inline void cTankNode::clear_list() {
  list_.Clear();
}
inline const ::cBufferNode& cTankNode::list(int index) const {
  return list_.Get(index);
}
inline ::cBufferNode* cTankNode::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::cBufferNode* cTankNode::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cBufferNode >&
cTankNode::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::cBufferNode >*
cTankNode::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// sEnter

// required int32 result = 1;
inline bool sEnter::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sEnter::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sEnter::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sEnter::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 sEnter::result() const {
  return result_;
}
inline void sEnter::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string message = 2;
inline bool sEnter::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sEnter::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sEnter::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sEnter::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& sEnter::message() const {
  return *message_;
}
inline void sEnter::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void sEnter::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void sEnter::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sEnter::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* sEnter::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sEnter::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sAddTank

// required .TankProtocol.cTankNode node = 1;
inline bool sAddTank::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sAddTank::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sAddTank::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sAddTank::clear_node() {
  if (node_ != NULL) node_->::TankProtocol::cTankNode::Clear();
  clear_has_node();
}
inline const ::TankProtocol::cTankNode& sAddTank::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::TankProtocol::cTankNode* sAddTank::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::TankProtocol::cTankNode;
  return node_;
}
inline ::TankProtocol::cTankNode* sAddTank::release_node() {
  clear_has_node();
  ::TankProtocol::cTankNode* temp = node_;
  node_ = NULL;
  return temp;
}
inline void sAddTank::set_allocated_node(::TankProtocol::cTankNode* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
}

// -------------------------------------------------------------------

// cGetTankList

// -------------------------------------------------------------------

// sGetTankList

// repeated .TankProtocol.cTankNode list = 1;
inline int sGetTankList::list_size() const {
  return list_.size();
}
inline void sGetTankList::clear_list() {
  list_.Clear();
}
inline const ::TankProtocol::cTankNode& sGetTankList::list(int index) const {
  return list_.Get(index);
}
inline ::TankProtocol::cTankNode* sGetTankList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::TankProtocol::cTankNode* sGetTankList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TankProtocol::cTankNode >&
sGetTankList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::TankProtocol::cTankNode >*
sGetTankList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// cAttack

// required int32 AttackTankId = 1;
inline bool cAttack::has_attacktankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cAttack::set_has_attacktankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cAttack::clear_has_attacktankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cAttack::clear_attacktankid() {
  attacktankid_ = 0;
  clear_has_attacktankid();
}
inline ::google::protobuf::int32 cAttack::attacktankid() const {
  return attacktankid_;
}
inline void cAttack::set_attacktankid(::google::protobuf::int32 value) {
  set_has_attacktankid();
  attacktankid_ = value;
}

// required int32 beAttackedTankId = 2;
inline bool cAttack::has_beattackedtankid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cAttack::set_has_beattackedtankid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cAttack::clear_has_beattackedtankid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cAttack::clear_beattackedtankid() {
  beattackedtankid_ = 0;
  clear_has_beattackedtankid();
}
inline ::google::protobuf::int32 cAttack::beattackedtankid() const {
  return beattackedtankid_;
}
inline void cAttack::set_beattackedtankid(::google::protobuf::int32 value) {
  set_has_beattackedtankid();
  beattackedtankid_ = value;
}

// required int32 damage = 3;
inline bool cAttack::has_damage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cAttack::set_has_damage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cAttack::clear_has_damage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cAttack::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 cAttack::damage() const {
  return damage_;
}
inline void cAttack::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
}

// -------------------------------------------------------------------

// sAttack

// required int32 AttackTankId = 1;
inline bool sAttack::has_attacktankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sAttack::set_has_attacktankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sAttack::clear_has_attacktankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sAttack::clear_attacktankid() {
  attacktankid_ = 0;
  clear_has_attacktankid();
}
inline ::google::protobuf::int32 sAttack::attacktankid() const {
  return attacktankid_;
}
inline void sAttack::set_attacktankid(::google::protobuf::int32 value) {
  set_has_attacktankid();
  attacktankid_ = value;
}

// required int32 beAttackedTankId = 2;
inline bool sAttack::has_beattackedtankid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sAttack::set_has_beattackedtankid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sAttack::clear_has_beattackedtankid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sAttack::clear_beattackedtankid() {
  beattackedtankid_ = 0;
  clear_has_beattackedtankid();
}
inline ::google::protobuf::int32 sAttack::beattackedtankid() const {
  return beattackedtankid_;
}
inline void sAttack::set_beattackedtankid(::google::protobuf::int32 value) {
  set_has_beattackedtankid();
  beattackedtankid_ = value;
}

// required int32 damage = 3;
inline bool sAttack::has_damage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sAttack::set_has_damage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sAttack::clear_has_damage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sAttack::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 sAttack::damage() const {
  return damage_;
}
inline void sAttack::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
}

// -------------------------------------------------------------------

// cUpdateTankPos

// required int32 tankId = 1;
inline bool cUpdateTankPos::has_tankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cUpdateTankPos::set_has_tankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cUpdateTankPos::clear_has_tankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cUpdateTankPos::clear_tankid() {
  tankid_ = 0;
  clear_has_tankid();
}
inline ::google::protobuf::int32 cUpdateTankPos::tankid() const {
  return tankid_;
}
inline void cUpdateTankPos::set_tankid(::google::protobuf::int32 value) {
  set_has_tankid();
  tankid_ = value;
}

// required .cVector3 position1 = 2;
inline bool cUpdateTankPos::has_position1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cUpdateTankPos::set_has_position1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cUpdateTankPos::clear_has_position1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cUpdateTankPos::clear_position1() {
  if (position1_ != NULL) position1_->::cVector3::Clear();
  clear_has_position1();
}
inline const ::cVector3& cUpdateTankPos::position1() const {
  return position1_ != NULL ? *position1_ : *default_instance_->position1_;
}
inline ::cVector3* cUpdateTankPos::mutable_position1() {
  set_has_position1();
  if (position1_ == NULL) position1_ = new ::cVector3;
  return position1_;
}
inline ::cVector3* cUpdateTankPos::release_position1() {
  clear_has_position1();
  ::cVector3* temp = position1_;
  position1_ = NULL;
  return temp;
}
inline void cUpdateTankPos::set_allocated_position1(::cVector3* position1) {
  delete position1_;
  position1_ = position1;
  if (position1) {
    set_has_position1();
  } else {
    clear_has_position1();
  }
}

// required .cVector3 position2 = 3;
inline bool cUpdateTankPos::has_position2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cUpdateTankPos::set_has_position2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cUpdateTankPos::clear_has_position2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cUpdateTankPos::clear_position2() {
  if (position2_ != NULL) position2_->::cVector3::Clear();
  clear_has_position2();
}
inline const ::cVector3& cUpdateTankPos::position2() const {
  return position2_ != NULL ? *position2_ : *default_instance_->position2_;
}
inline ::cVector3* cUpdateTankPos::mutable_position2() {
  set_has_position2();
  if (position2_ == NULL) position2_ = new ::cVector3;
  return position2_;
}
inline ::cVector3* cUpdateTankPos::release_position2() {
  clear_has_position2();
  ::cVector3* temp = position2_;
  position2_ = NULL;
  return temp;
}
inline void cUpdateTankPos::set_allocated_position2(::cVector3* position2) {
  delete position2_;
  position2_ = position2;
  if (position2) {
    set_has_position2();
  } else {
    clear_has_position2();
  }
}

// required .cVector3 position3 = 4;
inline bool cUpdateTankPos::has_position3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cUpdateTankPos::set_has_position3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cUpdateTankPos::clear_has_position3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cUpdateTankPos::clear_position3() {
  if (position3_ != NULL) position3_->::cVector3::Clear();
  clear_has_position3();
}
inline const ::cVector3& cUpdateTankPos::position3() const {
  return position3_ != NULL ? *position3_ : *default_instance_->position3_;
}
inline ::cVector3* cUpdateTankPos::mutable_position3() {
  set_has_position3();
  if (position3_ == NULL) position3_ = new ::cVector3;
  return position3_;
}
inline ::cVector3* cUpdateTankPos::release_position3() {
  clear_has_position3();
  ::cVector3* temp = position3_;
  position3_ = NULL;
  return temp;
}
inline void cUpdateTankPos::set_allocated_position3(::cVector3* position3) {
  delete position3_;
  position3_ = position3;
  if (position3) {
    set_has_position3();
  } else {
    clear_has_position3();
  }
}

// required .cVector3 direction = 5;
inline bool cUpdateTankPos::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cUpdateTankPos::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cUpdateTankPos::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cUpdateTankPos::clear_direction() {
  if (direction_ != NULL) direction_->::cVector3::Clear();
  clear_has_direction();
}
inline const ::cVector3& cUpdateTankPos::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::cVector3* cUpdateTankPos::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::cVector3;
  return direction_;
}
inline ::cVector3* cUpdateTankPos::release_direction() {
  clear_has_direction();
  ::cVector3* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void cUpdateTankPos::set_allocated_direction(::cVector3* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
}

// optional int32 hp = 6;
inline bool cUpdateTankPos::has_hp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cUpdateTankPos::set_has_hp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cUpdateTankPos::clear_has_hp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cUpdateTankPos::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 cUpdateTankPos::hp() const {
  return hp_;
}
inline void cUpdateTankPos::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// required int32 damage = 7;
inline bool cUpdateTankPos::has_damage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cUpdateTankPos::set_has_damage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cUpdateTankPos::clear_has_damage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cUpdateTankPos::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 cUpdateTankPos::damage() const {
  return damage_;
}
inline void cUpdateTankPos::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
}

// repeated .cBufferNode list = 8;
inline int cUpdateTankPos::list_size() const {
  return list_.size();
}
inline void cUpdateTankPos::clear_list() {
  list_.Clear();
}
inline const ::cBufferNode& cUpdateTankPos::list(int index) const {
  return list_.Get(index);
}
inline ::cBufferNode* cUpdateTankPos::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::cBufferNode* cUpdateTankPos::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cBufferNode >&
cUpdateTankPos::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::cBufferNode >*
cUpdateTankPos::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// cAddBuff

// required int32 tankId = 1;
inline bool cAddBuff::has_tankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cAddBuff::set_has_tankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cAddBuff::clear_has_tankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cAddBuff::clear_tankid() {
  tankid_ = 0;
  clear_has_tankid();
}
inline ::google::protobuf::int32 cAddBuff::tankid() const {
  return tankid_;
}
inline void cAddBuff::set_tankid(::google::protobuf::int32 value) {
  set_has_tankid();
  tankid_ = value;
}

// required int32 bufferId = 2;
inline bool cAddBuff::has_bufferid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cAddBuff::set_has_bufferid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cAddBuff::clear_has_bufferid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cAddBuff::clear_bufferid() {
  bufferid_ = 0;
  clear_has_bufferid();
}
inline ::google::protobuf::int32 cAddBuff::bufferid() const {
  return bufferid_;
}
inline void cAddBuff::set_bufferid(::google::protobuf::int32 value) {
  set_has_bufferid();
  bufferid_ = value;
}

// -------------------------------------------------------------------

// sAddBuff

// required int32 tankId = 1;
inline bool sAddBuff::has_tankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sAddBuff::set_has_tankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sAddBuff::clear_has_tankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sAddBuff::clear_tankid() {
  tankid_ = 0;
  clear_has_tankid();
}
inline ::google::protobuf::int32 sAddBuff::tankid() const {
  return tankid_;
}
inline void sAddBuff::set_tankid(::google::protobuf::int32 value) {
  set_has_tankid();
  tankid_ = value;
}

// required int32 bufferId = 2;
inline bool sAddBuff::has_bufferid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sAddBuff::set_has_bufferid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sAddBuff::clear_has_bufferid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sAddBuff::clear_bufferid() {
  bufferid_ = 0;
  clear_has_bufferid();
}
inline ::google::protobuf::int32 sAddBuff::bufferid() const {
  return bufferid_;
}
inline void sAddBuff::set_bufferid(::google::protobuf::int32 value) {
  set_has_bufferid();
  bufferid_ = value;
}

// -------------------------------------------------------------------

// sAddBuffToBattleField

// required .cBufferNode buffer = 1;
inline bool sAddBuffToBattleField::has_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sAddBuffToBattleField::set_has_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sAddBuffToBattleField::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sAddBuffToBattleField::clear_buffer() {
  if (buffer_ != NULL) buffer_->::cBufferNode::Clear();
  clear_has_buffer();
}
inline const ::cBufferNode& sAddBuffToBattleField::buffer() const {
  return buffer_ != NULL ? *buffer_ : *default_instance_->buffer_;
}
inline ::cBufferNode* sAddBuffToBattleField::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == NULL) buffer_ = new ::cBufferNode;
  return buffer_;
}
inline ::cBufferNode* sAddBuffToBattleField::release_buffer() {
  clear_has_buffer();
  ::cBufferNode* temp = buffer_;
  buffer_ = NULL;
  return temp;
}
inline void sAddBuffToBattleField::set_allocated_buffer(::cBufferNode* buffer) {
  delete buffer_;
  buffer_ = buffer;
  if (buffer) {
    set_has_buffer();
  } else {
    clear_has_buffer();
  }
}

// -------------------------------------------------------------------

// sCleanBuff

// required int32 id = 1;
inline bool sCleanBuff::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sCleanBuff::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sCleanBuff::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sCleanBuff::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 sCleanBuff::id() const {
  return id_;
}
inline void sCleanBuff::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// cGetBuffList

// -------------------------------------------------------------------

// sGetBuffList

// repeated .cBufferNode list = 1;
inline int sGetBuffList::list_size() const {
  return list_.size();
}
inline void sGetBuffList::clear_list() {
  list_.Clear();
}
inline const ::cBufferNode& sGetBuffList::list(int index) const {
  return list_.Get(index);
}
inline ::cBufferNode* sGetBuffList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::cBufferNode* sGetBuffList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cBufferNode >&
sGetBuffList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::cBufferNode >*
sGetBuffList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// cCannonNode

// required int32 cannonId = 1;
inline bool cCannonNode::has_cannonid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cCannonNode::set_has_cannonid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cCannonNode::clear_has_cannonid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cCannonNode::clear_cannonid() {
  cannonid_ = 0;
  clear_has_cannonid();
}
inline ::google::protobuf::int32 cCannonNode::cannonid() const {
  return cannonid_;
}
inline void cCannonNode::set_cannonid(::google::protobuf::int32 value) {
  set_has_cannonid();
  cannonid_ = value;
}

// required .cVector3 position1 = 2;
inline bool cCannonNode::has_position1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cCannonNode::set_has_position1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cCannonNode::clear_has_position1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cCannonNode::clear_position1() {
  if (position1_ != NULL) position1_->::cVector3::Clear();
  clear_has_position1();
}
inline const ::cVector3& cCannonNode::position1() const {
  return position1_ != NULL ? *position1_ : *default_instance_->position1_;
}
inline ::cVector3* cCannonNode::mutable_position1() {
  set_has_position1();
  if (position1_ == NULL) position1_ = new ::cVector3;
  return position1_;
}
inline ::cVector3* cCannonNode::release_position1() {
  clear_has_position1();
  ::cVector3* temp = position1_;
  position1_ = NULL;
  return temp;
}
inline void cCannonNode::set_allocated_position1(::cVector3* position1) {
  delete position1_;
  position1_ = position1;
  if (position1) {
    set_has_position1();
  } else {
    clear_has_position1();
  }
}

// required .cVector3 position2 = 3;
inline bool cCannonNode::has_position2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cCannonNode::set_has_position2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cCannonNode::clear_has_position2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cCannonNode::clear_position2() {
  if (position2_ != NULL) position2_->::cVector3::Clear();
  clear_has_position2();
}
inline const ::cVector3& cCannonNode::position2() const {
  return position2_ != NULL ? *position2_ : *default_instance_->position2_;
}
inline ::cVector3* cCannonNode::mutable_position2() {
  set_has_position2();
  if (position2_ == NULL) position2_ = new ::cVector3;
  return position2_;
}
inline ::cVector3* cCannonNode::release_position2() {
  clear_has_position2();
  ::cVector3* temp = position2_;
  position2_ = NULL;
  return temp;
}
inline void cCannonNode::set_allocated_position2(::cVector3* position2) {
  delete position2_;
  position2_ = position2;
  if (position2) {
    set_has_position2();
  } else {
    clear_has_position2();
  }
}

// required .cVector3 position3 = 4;
inline bool cCannonNode::has_position3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cCannonNode::set_has_position3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cCannonNode::clear_has_position3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cCannonNode::clear_position3() {
  if (position3_ != NULL) position3_->::cVector3::Clear();
  clear_has_position3();
}
inline const ::cVector3& cCannonNode::position3() const {
  return position3_ != NULL ? *position3_ : *default_instance_->position3_;
}
inline ::cVector3* cCannonNode::mutable_position3() {
  set_has_position3();
  if (position3_ == NULL) position3_ = new ::cVector3;
  return position3_;
}
inline ::cVector3* cCannonNode::release_position3() {
  clear_has_position3();
  ::cVector3* temp = position3_;
  position3_ = NULL;
  return temp;
}
inline void cCannonNode::set_allocated_position3(::cVector3* position3) {
  delete position3_;
  position3_ = position3;
  if (position3) {
    set_has_position3();
  } else {
    clear_has_position3();
  }
}

// required .cVector3 direction = 5;
inline bool cCannonNode::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cCannonNode::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cCannonNode::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cCannonNode::clear_direction() {
  if (direction_ != NULL) direction_->::cVector3::Clear();
  clear_has_direction();
}
inline const ::cVector3& cCannonNode::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::cVector3* cCannonNode::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::cVector3;
  return direction_;
}
inline ::cVector3* cCannonNode::release_direction() {
  clear_has_direction();
  ::cVector3* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void cCannonNode::set_allocated_direction(::cVector3* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
}

// required int32 damage = 6;
inline bool cCannonNode::has_damage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cCannonNode::set_has_damage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cCannonNode::clear_has_damage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cCannonNode::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 cCannonNode::damage() const {
  return damage_;
}
inline void cCannonNode::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
}

// required int32 area = 7;
inline bool cCannonNode::has_area() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cCannonNode::set_has_area() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cCannonNode::clear_has_area() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cCannonNode::clear_area() {
  area_ = 0;
  clear_has_area();
}
inline ::google::protobuf::int32 cCannonNode::area() const {
  return area_;
}
inline void cCannonNode::set_area(::google::protobuf::int32 value) {
  set_has_area();
  area_ = value;
}

// -------------------------------------------------------------------

// cGetCannonList

// -------------------------------------------------------------------

// sGetCannonList

// repeated .TankProtocol.cCannonNode list = 1;
inline int sGetCannonList::list_size() const {
  return list_.size();
}
inline void sGetCannonList::clear_list() {
  list_.Clear();
}
inline const ::TankProtocol::cCannonNode& sGetCannonList::list(int index) const {
  return list_.Get(index);
}
inline ::TankProtocol::cCannonNode* sGetCannonList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::TankProtocol::cCannonNode* sGetCannonList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TankProtocol::cCannonNode >&
sGetCannonList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::TankProtocol::cCannonNode >*
sGetCannonList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// sUpdateCannonAttack

// required int32 cannonId = 1;
inline bool sUpdateCannonAttack::has_cannonid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sUpdateCannonAttack::set_has_cannonid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sUpdateCannonAttack::clear_has_cannonid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sUpdateCannonAttack::clear_cannonid() {
  cannonid_ = 0;
  clear_has_cannonid();
}
inline ::google::protobuf::int32 sUpdateCannonAttack::cannonid() const {
  return cannonid_;
}
inline void sUpdateCannonAttack::set_cannonid(::google::protobuf::int32 value) {
  set_has_cannonid();
  cannonid_ = value;
}

// required int32 tankId = 2;
inline bool sUpdateCannonAttack::has_tankid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sUpdateCannonAttack::set_has_tankid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sUpdateCannonAttack::clear_has_tankid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sUpdateCannonAttack::clear_tankid() {
  tankid_ = 0;
  clear_has_tankid();
}
inline ::google::protobuf::int32 sUpdateCannonAttack::tankid() const {
  return tankid_;
}
inline void sUpdateCannonAttack::set_tankid(::google::protobuf::int32 value) {
  set_has_tankid();
  tankid_ = value;
}

// required int32 damage = 3;
inline bool sUpdateCannonAttack::has_damage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sUpdateCannonAttack::set_has_damage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sUpdateCannonAttack::clear_has_damage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sUpdateCannonAttack::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 sUpdateCannonAttack::damage() const {
  return damage_;
}
inline void sUpdateCannonAttack::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
}

// -------------------------------------------------------------------

// cDeath

// required int32 tankId = 1;
inline bool cDeath::has_tankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cDeath::set_has_tankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cDeath::clear_has_tankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cDeath::clear_tankid() {
  tankid_ = 0;
  clear_has_tankid();
}
inline ::google::protobuf::int32 cDeath::tankid() const {
  return tankid_;
}
inline void cDeath::set_tankid(::google::protobuf::int32 value) {
  set_has_tankid();
  tankid_ = value;
}

// -------------------------------------------------------------------

// sDeath

// required int32 tankId = 1;
inline bool sDeath::has_tankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sDeath::set_has_tankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sDeath::clear_has_tankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sDeath::clear_tankid() {
  tankid_ = 0;
  clear_has_tankid();
}
inline ::google::protobuf::int32 sDeath::tankid() const {
  return tankid_;
}
inline void sDeath::set_tankid(::google::protobuf::int32 value) {
  set_has_tankid();
  tankid_ = value;
}

// -------------------------------------------------------------------

// cReborn

// required int32 tankId = 1;
inline bool cReborn::has_tankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cReborn::set_has_tankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cReborn::clear_has_tankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cReborn::clear_tankid() {
  tankid_ = 0;
  clear_has_tankid();
}
inline ::google::protobuf::int32 cReborn::tankid() const {
  return tankid_;
}
inline void cReborn::set_tankid(::google::protobuf::int32 value) {
  set_has_tankid();
  tankid_ = value;
}

// -------------------------------------------------------------------

// sReborn

// required int32 tankId = 1;
inline bool sReborn::has_tankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sReborn::set_has_tankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sReborn::clear_has_tankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sReborn::clear_tankid() {
  tankid_ = 0;
  clear_has_tankid();
}
inline ::google::protobuf::int32 sReborn::tankid() const {
  return tankid_;
}
inline void sReborn::set_tankid(::google::protobuf::int32 value) {
  set_has_tankid();
  tankid_ = value;
}

// -------------------------------------------------------------------

// sLogout

// required int32 tankId = 1;
inline bool sLogout::has_tankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sLogout::set_has_tankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sLogout::clear_has_tankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sLogout::clear_tankid() {
  tankid_ = 0;
  clear_has_tankid();
}
inline ::google::protobuf::int32 sLogout::tankid() const {
  return tankid_;
}
inline void sLogout::set_tankid(::google::protobuf::int32 value) {
  set_has_tankid();
  tankid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TankProtocol

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fprotocol_2eproto__INCLUDED
